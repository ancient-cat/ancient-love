declare interface Lume {
  _version: string;
  clamp(x: number, min: number, max: number): number;
  round(x: number, increment?: number): number;
  sign(x: number): number;
  lerp(a: number, b: number, amount: number): number;
  smooth(a: number, b: number, amount: number): number;
  pingpong(x: number): number;
  distance(x1: number, y1: number, x2: number, y2: number, squared?: boolean): number;
  angle(x1: number, y1: number, x2: number, y2: number): number;
  vector(angle: number, magnitude: number): [number, number];
  random(a?: number, b?: number): number;
  randomchoice<T>(t: T[]): T;
  weightedchoice<T>(t: { [key: string]: number }): string;
  isarray(x: any): boolean;
  push<T>(t: T[], ...values: T[]): T[];
  remove<T>(t: T[], x: T): T;
  clear<T>(t: T[]): T[];
  extend<T>(t: T, ...sources: Partial<T>[]): T;
  shuffle<T>(t: T[]): T[];
  sort<T>(t: T[], comp?: ((a: T, b: T) => boolean) | string): T[];
  array<T>(iterable: Iterable<T>): T[];
  each<T>(t: T[], fn: (v: T, ...args: any[]) => void, ...args: any[]): T[];
  map<T, U>(t: T[], fn: (v: T) => U): U[];
  all<T>(t: T[], fn: (v: T) => boolean): boolean;
  any<T>(t: T[], fn: (v: T) => boolean): boolean;
  reduce<T, U>(t: T[], fn: (acc: U, v: T) => U, first?: U): U;
  unique<T>(t: T[]): T[];
  filter<T>(t: T[], fn: (v: T) => boolean, retainkeys?: boolean): T[];
  reject<T>(t: T[], fn: (v: T) => boolean, retainkeys?: boolean): T[];
  merge<T>(...tables: Partial<T>[]): T;
  concat<T>(...tables: T[]): T[];
  find<T>(t: T[], value: T): number | undefined;
  match<T>(t: T[], fn: (v: T) => boolean): [T, number] | undefined;
  count<T>(t: T[], fn?: (v: T) => boolean): number;
  slice<T>(t: T[], i?: number, j?: number): T[];
  first<T>(t: T[], n?: number): T | T[];
  last<T>(t: T[], n?: number): T | T[];
  invert<T>(t: { [key: string]: T }): { [key: string]: string };
  pick<T>(t: T, ...keys: (keyof T)[]): Partial<T>;
  keys<T>(t: T): (keyof T)[];
  clone<T>(t: T): T;
  fn(fn: Function, ...args: any[]): Function;
  once(fn: Function, ...args: any[]): Function;
  memoize<T extends Function>(fn: T): T;
  combine(...fns: Function[]): Function;
  call(fn: Function | undefined, ...args: any[]): any;
  time<T>(fn: Function, ...args: any[]): [number, T];
  lambda(str: string): Function;
  serialize(x: any): string;
  deserialize(str: string): any;
  split(str: string, sep?: string): string[];
  trim(str: string, chars?: string): string;
  wordwrap(str: string, limit?: number): string;
  format(str: string, vars?: { [key: string]: any }): string;
  trace(...args: any[]): void;
  dostring(str: string): any;
  uuid(): string;
}

declare const lume: Lume;
export default lume;
